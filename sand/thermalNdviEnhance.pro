;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Reads an enviheader file.  ;;	    returns a struct :;;		    ns:number of samples in the file;;		    nl:number of lines in the file;;		    nb:number of bands in the file;;		    map: an envi map structure (includes utm coords and pixelsize);;		    desc: The description field in the .hdr;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getFileInfo, name	 envi_open_file, name, r_fid=id	 	 if id eq -1 then return, {errorstruct, name:name, ns:-1, nl:-1, nb:-1}	 envi_file_query, id, nb=nb, nl=nl, ns=ns, h_map=maph, descrip=desc, $	 	interleave=interleave, data_type=type	 if maph eq -1 then return, {errorstruct, name:name, ns:-1, nl:-1, nb:-1}	 	 handle_value, maph, map	 envi_file_mng, id=id, /remove	 return, {imagestruct, name:name, ns:ns, nl:nl, nb:nb, map:map, desc:desc, $	 	interleave:interleave, type:type}end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Sets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro setHdr, info, fname	envi_setup_head, fname=fname, ns=info.ns, nl=info.nl, nb=info.nb, $		interleave=info.interleave, data_type=info.type, $		descrip=info.desc, map_info=info.map, /writeend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	determines if the inputfile is useable by this program;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function verify, info	if info.ns eq -1 then begin		print, 'ERROR reading ENVI .hdr file for : ', input		return, -1	endif	if info.type gt 4 then begin		print, 'ERROR : ',input,' is not of type byte, integer, long, or float'		return, -1	endif	if info.nb gt 3 then begin		print, 'ERROR : ',input,' has too many bands.'		return, -1	endif	return, 1end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;return the mode of an arrayfunction mode, array	hist=histogram(array, min=0, max=255)	index = where(hist eq max(hist))		if n_elements(index) gt 1 then $		return, byte(mean(index))		return,byte(index(0))end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;copies all but the last band from the open file unit un to the open (for writing);;	file unit oun.  info is a file info struct from the input unpro writeBands, un, oun, info		line=make_array(info.ns, type=info.type);;Make sure we can preserve our current position in the file		oldPtr=(fstat(un)).cur_ptr	point_lun, un, 0;;loop through all but the last band and loop through all lines		for i=0, info.nb-2 do begin	for j=0, info.nl-1 do begin		readu, un, line		writeu, oun, line	endfor	endfor;;reset the file pointer to where it was when we started	point_lun, un, oldPtrend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;start envi in batch modepro envistartenvi, /restore_base_save_filesenvi_init, /batch_modeend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Uses Susan Moran's Window based technique to enhance a band 6 image with an NDVI;;	image.  Moran(1990), PE&RS, v.56,no3, pp. 347-342;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro thermalNdviEnhance, input, output		if n_elements(output) eq 0 then begin		print, ' '		print, 'pro thermalNdviEnhance, input, output'		print, ' '		return	endif;;Loads ENVI if it is not already loaded.  Necessary for reading .hdr files;;  IDL prior to 5.4 may not compile this code until envi is started	envistart	;;Read ENVI .hdr information and check to see if we can work with this file	info=getFileInfo(input)	if verify(info) eq -1 then return;;Open the files in IDL	openr, un, input, /get	openw, oun, output, /get;;this is just a multiplier for point_lun and two offsets	sizes=[1,2,4,4]	Dtype=sizes(info.type-1)	bandOffset=info.ns*info.nl*Dtype	lineOffset=info.ns*Dtype	;; series of data types for reading from a file, converting to NDVI and makeing a window		B6line = make_array(info.ns, 25, type=info.type)	B3line = make_array(info.ns, 24, type=info.type)	B4line = make_array(info.ns, 24, type=info.type)	NDVIline=bytarr(info.ns, 25)	B6tmpl = make_array(info.ns, type=info.type)	B3tmpl = make_array(info.ns, type=info.type)	B4tmpl = make_array(info.ns, type=info.type)		B6win=make_array(25, 25, type=info.type)	Nwin= bytarr(25, 25);;this is just an array of zeros to write at the beginning and end of every line ;;	because we can't make the first or last 12 pixels higher resolution	lineBuffer = make_array(12, type=info.type);;write the first 12 lines blank because we can't make them higher resolution	writeu, oun, B6line(*,0:11);;Initialize our variables from the input file		readu, un, B3line	point_lun, un, bandOffset	readu, un, B4line	point_lun, un, bandOffset*2	readu, un, B6line	point_lun, un, (fstat(un)).cur_ptr - bandOffset*2	NDVIline(*,0:23) = byte(255* (float(B4line) - B3line)/(Float(B4line)+B3line))		nextLine=24	lineCenter=12	;;first write Bands 3 and 4 to the new file	writeBands, un, oun, info	for line=0, info.nl-26 do begin;;read the next single line of data from each band and place it in the ;; proper place within the full 25 line window.  		readu, un, b3tmpl		point_lun, un, (fstat(un)).cur_ptr + bandOffset - lineOffset		readu, un, b4tmpl		point_lun, un, (fstat(un)).cur_ptr + bandOffset - lineOffset		readu, un, b6tmpl				point_lun, un, (fstat(un)).cur_ptr - bandOffset*2				B6line(*,nextLine) = b6tmpl		NDVIline(*,nextLine) = byte(255* (float(B4tmpl) - B3tmpl)/(Float(B4tmpl)+B3tmpl));;just copy the first 12 samples directly to the output to maintain filesize		writeu, oun, lineBuffer;;Within this line compute the mode of all the matching pixels in each 25x25 window;; use the NDVI image to match the 		B6win = B6line(0:24,*)		Nwin = NDVIline(0:24,*)		linepos = 24		centerpos = 12		for i=0, info.ns-25 do begin			B6win(linepos,*) = B6line(i+24,*)			Nwin(linepos,*)  = NDVIline(i+24,*)			center=Nwin(centerpos,lineCenter)						centerpos = (centerpos+1) mod 25			linepos = (linepos+1) mod 25;;Moran(1990) uses a threshold of 0.05 in scaled 0-255 NDVI 0.05 = 13						index=where(Nwin-center lt 13 and center-Nwin lt 13)			if index(0) ne -1 then $				writeu, oun, mode(B6win(index))					endfor;;increment our counter to keep track of where we are in the 25 line segment		nextLine=(nextLine +1) mod 25		lineCenter=(lineCenter+1) mod 25		;;similar to the begining of a line, write the final 12 samples.  		;		writeu, oun, B6tmpl(info.ns-12:info.ns-1)		writeu, oun, lineBuffer	;		tvscl, B6line((info.ns/2):((info.ns/2)+300), *),0;		tvscl, NDVIline((info.ns/2):((info.ns/2)+300), *),1				endfor;; all of these conditional statements are no longer needed they were used to find;;	the correct thirteen lines to write at the end	B6line(*,*) = 0	if nextLine le 13 then begin		if nextLine eq 0 then writeu, oun, B6line(*,0:12) $		else writeu, oun, B6line(*,nextLine-1:nextLine+11)	endif else begin		writeu, oun, B6line(*,nextLine:24)		writeu, oun, B6line(*,0:(nextLine-13))	endelse		close, oun, un	free_lun, oun, un	setHdr, info, output	end