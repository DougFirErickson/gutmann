;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	ENVI MUST BE RESTORED BEFORE THIS WILL COMPILE!!;;;;	Takes an ENVI vector file and an ENVI image file as ;;	input.  Uses the image file to determine the location;;	of the output mask.  Reads polygons from the evf ;;	converts them into image space, makes an ROI from them;;	and converts the ROI to a mask over the same location;;	as the image file.  Outputs a Byte mask file that is ;;	identical to the imagefile in size and location and ;;	has a similar ENVI header file with it;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro evfToMask, evfFile, imagefile, maskfilefunction shiftcoords, coords, outputproj, inputproj	envi_convert_projection_coordinates, transpose(coords[0,*]),$		transpose(coords[1,*]),inputproj, outX,outY,outputproj	return, [transpose(outX),transpose(outY)]endfunction imagespace, mapcoords, mapinfo		mapcoords[0,*]=round((mapcoords[0,*] - mapinfo.mc[2])/mapinfo.ps[0]) - mapinfo.mc[0]	mapcoords[1,*]=round((mapinfo.mc[3] - mapcoords[1,*])/mapinfo.ps[1]) - mapinfo.mc[1]	return, long(mapcoords)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	return a byte mask ns x nl based on the roi specified by roi_id;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function buildmask,roi_id, ns, nl;	tot=ns*nl;;	data=envi_get_roi(roi_id);	index = where(data ge 0 and data lt tot);	if index(0) eq -1 then return, -1;	;	if n_elements(data) ne n_elements(index) then $;		data=data(index);;	index = 0;;	mask=bytarr(ns, nl);	mask(data) = 1;;	return, mask;end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	return a byte mask ns x nl based on the roi specified by roi_id;;		in addition, cut out the roi specified by cut_roi;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function buildfinalmask, roi_id, cut_roi, ns, nl	tot=ns*nl	data=envi_get_roi(roi_id)		index = where(data ge 0 and data lt tot)	if index(0) eq -1 then begin		print, 'No valid data in ROI'		return, -1	endif		if n_elements(data) ne n_elements(index) then $		data=data(index)	index = 0	mask=bytarr(ns, nl)	mask(data) = 1	data=0		hole=envi_get_roi(cut_roi)	holdex = where(hole ge 0 and hole lt tot)	if holdex(0) eq -1 then return, mask		mask(hole(holdex)) = 0	return, mask	end;; write the final mask to the mask output filepro outputmask, mask, fname, imgfid;; write the data to a file	openw, oun, fname, /get	writeu, oun, mask	free_lun, oun;; get the necessary envi header info	envi_file_query, imgfid, h_map=maph, ns=ns, nl=nl, $		xstart=xs, ystart=ys	handle_value, maph, map_info;; write the necessary envi header info	envi_setup_head, data_type=1, file_type=0, fname=fname,$		interleave=0, map_info=map_info, nb=1,ns=ns,nl=nl,$		xstart=xs,ystart=ys, /writeend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	sort through all of the polygons in a set of nested polygons;;;	return the pixel areas of each, and the starting and ending;;;	points of each.  deep Recursion hits IDL HARD!! (this one goes 303 deep:);;;;;;	EDIT 4/13/01 Took out recursion, too expensive time and memory wise;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getmasks, cur_rec, first, ns, nl;;;; Find all of the places where we come back to the starting pixel.  ;	tmpindex = where(cur_rec(0,*) eq cur_rec(0,0) and cur_rec(1,*) eq cur_rec(1,0));	last = tmpindex(n_elements(tmpindex)-1);	list={roidata, mask:0l, poly:[0,0l]};	;	while last ne n_elements(cur_rec(0,*))-1 do begin;		if last gt n_elements(cur_rec(0,*))-1 then print, 'POLYGON DOES NOT CLOSE!';;		if (last-first) gt 1 then begin;			tmproi = envi_create_roi(ns=ns, nl=nl);			envi_define_roi, tmproi, /polygon, $;				xpts=transpose(cur_rec[0,first:last]), $;				ypts=transpose(cur_rec[1,first:last])		;			mask=buildmask(tmproi, ns, nl);		;			if mask(0) eq -1 then size = 0 $;			else begin;	;		size= n_elements(where(mask eq 1));				size=0;				tmpsize=where(mask(*,0) eq 1);				if tmpsize(0) ne -1 then $;					size=n_elements(tmpsize);				for i=1,n_elements(mask(0,*))-1 do begin;					tmpsize=where(mask(*,i) eq 1);					if tmpsize(0) ne -1 then $;						size=size+n_elements(tmpsize);				endfor;			endelse;			envi_delete_rois, tmproi;		endif else $;			size=0;		mask=0;		;		list= [list, {roidata, mask:size, poly:[first,last]}];		;		first = last+1 ;		tmpindex = where(cur_rec(0,*) eq cur_rec(0,first) and cur_rec(1,*) eq cur_rec(1,first));		last = tmpindex(n_elements(tmpindex)-1);	endwhile;;;;;;;OK, this is the last one;;	if last-first gt 1 then begin;		tmproi = envi_create_roi(ns=ns, nl=nl);	;		envi_define_roi, tmproi, /polygon, $;			xpts=transpose(cur_rec[0,first:last]), $;			ypts=transpose(cur_rec[1,first:last]);		mask=buildmask(tmproi, ns, nl);		;		envi_delete_rois, tmproi;	;		;		if mask(0) eq -1 then size = 0 $;		else begin;	;	;		size= n_elements(where(mask eq 1));			size=0;			tmpsize=where(mask(*,0) eq 1);			if tmpsize(0) ne -1 then $;				size=n_elements(tmpsize);			for i=1,n_elements(mask(0,*))-1 do begin;				tmpsize=where(mask(*,i) eq 1);				if tmpsize(0) ne -1 then $;					size=size+n_elements(tmpsize);			endfor;			mask=0;		endelse;	endif else size=0;	list= [list, {roidata, mask:size, poly:[first,last]}];	;	return, list[1:n_elements(list)-1];end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	ultra fastversion.  Just finds the polygon starting and stopping points;;		this ASSUMES that the first polygon in a set is always the external;;		polygon.  This seems to be true for the entire sand.evf created from ;;		the Statsco data .shp file, but not true for any of the rangeland files;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function polyIndices, cur_rec	tmpindex = where(cur_rec(0,*) eq cur_rec(0,0) and cur_rec(1,*) eq cur_rec(1,0))	last = tmpindex(n_elements(tmpindex)-1)	list={roidata, mask:50l, poly:[0l,last]}	while last ne n_elements(cur_rec(0,*))-1 do begin		first=last+1		tmpindex = where(cur_rec(0,*) eq cur_rec(0,first) and $			cur_rec(1,*) eq cur_rec(1,first))		last = tmpindex(n_elements(tmpindex)-1)		list= [list, {roidata, mask:0l, poly:[first,last]}]	endwhile		return, listendpro addToRois, cur_rec, roi_id, cut_roi, last, ns, nl		indices = polyIndices(cur_rec)		for i=0, n_elements(indices)-1 do begin			;;search for the largest polygon in the group, call it external and the others;; internal.  all internal polygons must be contained in the external one, thus;; they must be smaller;pro addinternal, cur_rec, fullroi, cutroi, last, ns, nl, fast=fast;;	if keyword_set(fast) then result = polyIndices(cur_rec) $;	else result = getmasks(cur_rec, 0, ns, nl);;	sizes=(result(*)).mask;	polys=(result(*)).poly;;	nmasks = n_elements(masks);	;; find the largest mask coverage.  This must be the external polygon;	;; all the rest are internal and should be added to the curroi;	largest=max(sizes);;;;there is a GOOD chance that these polygons do not fall inside the image;;; thus where returns -1 and the "size" is considered 1 in this case we ;;; shouldn't bother doing anything.  We should just return;	if largest le 1 then return;;	print, 'Sizes:', sizes;;	index = where(sizes ne largest);	for i=0, n_elements(index)-1 do begin;;; finally add it to the roi that will be used to cut holes;		first= polys(0,index(i));		last = polys(1,index(i));		if last-first gt 1 then $;			envi_define_roi, cutroi, /polygon, $;				xpts=transpose(cur_rec[0,first:last]), $;				ypts=transpose(cur_rec[1,first:last]);	endfor;	;	index = where(sizes eq largest) ;;hopefully this is only one element!;	if n_elements(index) gt 1 then print, 'ERROR: more than one largest',$;			' rois', n_elements(index), ' of size ', sizes(index(0));;	i=index(0);	;	if i ne 0 then print, 'Found one (',cur_rec(*,0),');;	first= polys(0,i);	last = polys(1,i);		if last-first gt 1 then $;			envi_define_roi, cutroi, /polygon, $;				xpts=transpose(cur_rec[0,first:last]), $;				ypts=transpose(cur_rec[1,first:last]);;end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Main Program;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro evfToMask, evfFile, imagefile, maskfile, fast=fast;; open and read basic parameters from the vector file	evf_id=envi_evf_open(evfFile)	envi_evf_info, evf_id, num_recs=num_recs, $		projection=projection	print,'Num Recs  : ', num_recs	print,'Projection: ', projection.name;; open and read basic parameters from the image file	envi_open_file, imagefile, r_fid=imgfid	envi_file_query, imgfid, h_map=maph, ns=ns, nl=nl, $		xstart=xs, ystart=ys	handle_value,maph, mapinfo;; determine if we need to convert projection coordinates	convert= (mapinfo.proj).name ne projection.name or $		(mapinfo.proj).params[0] ne projection.params[0]	if convert then print, 'Will CONVERT projections';; define the basic ROI template we are going to use	roi_id = envi_create_roi(ns=ns, nl=nl)	cutroi = envi_create_roi(ns=ns, nl=nl);; loop through all records.  For each, convert it to image map;;   space if necessary, then convert it to image pixel coordinates;;   once in pixels coordinates, add it to the ROI.  note,;;   images coordinates can be negative, define_roi will truncate it	for i=0,num_recs-1 do begin;; get the next polygon		cur_rec = envi_evf_read_record(evf_id, i);; if necessary convert it to image map space		if convert then $			cur_rec=shiftcoords(cur_rec, mapinfo.proj, projection);; convert polygon to image pixel coordinates		cur_rec=imageSpace(cur_rec, mapinfo);; Search for polygons which have internal polygons tacked on to the end		tmpindex = where(cur_rec(0,*) eq cur_rec(0,0) and cur_rec(1,*) eq cur_rec(1,0))		last = tmpindex(n_elements(tmpindex)-1)		if last ne n_elements(cur_rec(0,*))-1 then begin			addToRois, cur_rec, roi_id, cut_roi, last, ns, nl;;OLD WAY, DOESN'T WORK;; if we have internal polygons, keep track of them and leave the external one		;;			addinternal, cur_rec, roi_id, cutroi, last, ns, nl, fast=fast		endif else begin;; finally add it to the roi, note this doesn't account for ;;   holes made up of overlapping regions (though this could be done with;;   seperate rois if necessary, just harder)			if n_elements(cur_rec(0,*)) gt 2 then $				if isInternal(cur_rec) then begin					envi_define_roi, cut_roi, /polygon, $						xpts=transpose(cur_rec[0,*]), $						ypts=transpose(cur_rec[1,*])								endif else $					envi_define_roi, roi_id, /polygon, $						xpts=transpose(cur_rec[0,*]), $						ypts=transpose(cur_rec[1,*])		endelse		tmp = fix((float(i)/num_recs) *1000)		if tmp mod 100 eq 0 then $			print, fix(float(i)/num_recs *100), '%'			endfor;; convert the ROI into a mask	mask=buildFinalmask(roi_id, cutroi, ns, nl)	envi_delete_rois, roi_id	envi_delete_rois, cutroi	print, 'Closing EVF file...'	envi_evf_close, evf_fid;; output the mask to an image file with an ENVI header	if mask(0) eq -1 then begin		print, 'EVF ERROR converting to mask, -1'		envi_file_mng, id=imgfid, /remove		return	endif	outputmask, mask, maskfile, imgfid	print, 'Closeing image file...'	envi_file_mng, id=imgfid, /remove	print, 'Done'end