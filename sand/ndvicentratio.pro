;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Reads an enviheader file.  ;;	    returns a struct :;;		    ns:number of samples in the file;;		    nl:number of lines in the file;;		    nb:number of bands in the file;;		    map: an envi map structure (includes utm coords and pixelsize);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getFileInfo, name	 envi_open_file, name, r_fid=id	 	 if id eq -1 then return, {errorstruct, name:name, ns:-1, nl:-1, nb:-1}	 envi_file_query, id, nb=nb, nl=nl, ns=ns, h_map=maph	 handle_value, maph, map	 envi_file_mng, id=id, /remove	 print, name	 return, {imagestruct, name:name, ns:ns, nl:nl, nb:nb, map:map}end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Finds the offsets in number of pixels between two images;;	note, this offset can be negative!;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function calcOffset, im1, im2 	 xoff=(im1.map.mc(2) - im2.map.mc(2))/im2.map.ps(0)	 yoff=(im2.map.mc(3) - im1.map.mc(3))/im2.map.ps(1)	 ratio = im2.map.ps(0) / im1.map.ps(0)	 	 return, {offsetstruct, x:fix(xoff), y:fix(yoff), factor:ratio}endpro ndvicentratio, cent, ndvi, output	n_info=getFileInfo(ndvi)	c_info=getFileInfo(cent)	if n_info.ns eq -1 or c_info.ns eq -1 then begin		print, 'ERROR OPENING FILE one of these files ', n_info, c_info		print, 'guess which one, hint -1 is bad and NDVI FID=', n_info.ns, 'Cent FID=', c_info.ns		return	endif	n_c_off=calcOffset(n_info, c_info)	if n_c_off.x lt 0 or n_c_off.y lt 0 or n_c_off.x lt 0 or n_c_off.y lt 0 then begin		print, 'Offset Error', n_c_off		return	endif	n_line=bytarr(n_info.ns)	c_line=fltarr(c_info.ns)	o_line=fltarr(n_info.ns)		openr, nun, /get, ndvi	openr, cun, /get, cent	openw, oun, /get, output	for i=0, n_c_off.y do readu, cun, c_line	for bandnum=0, n_info.nb-1 do begin	for i=0, n_info.nl-1 do begin			readu, nun, n_line		if i mod n_c_off.factor eq 0 then $			readu, cun, c_line		n_index = where(n_line ne 0)		if n_index(0) ne -1 then begin			c_index = fix((n_index / n_c_off.factor) + n_c_off.x)			o_line(n_index) = n_line(n_index) /  c_line(c_index)		endif		index = where(o_line gt 3)		if index(0) ne -1 then o_line(index) = 3.0		writeu, oun, byte((o_line-0.5) * 100)		o_line(*) = 0.	endfor	point_lun, cun, c_info.nl*c_info.ns *4	endforclose, nun, cun, ounfree_lun, nun, cun, ounend