;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Reads an enviheader file.  ;;	    returns a struct :;;		    ns:number of samples in the file;;		    nl:number of lines in the file;;		    nb:number of bands in the file;;		    map: an envi map structure (includes utm coords and pixelsize);;		    desc: The description field in the .hdr;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getFileInfo, name	 envi_open_file, name, r_fid=id	 	 if id eq -1 then return, {errorstruct, name:name, ns:-1, nl:-1, nb:-1}	 envi_file_query, id, nb=nb, nl=nl, ns=ns, h_map=maph, descrip=desc, $	 	interleave=interleave, data_type=type	 handle_value, maph, map	 envi_file_mng, id=id, /remove	 return, {imagestruct, name:name, ns:ns, nl:nl, nb:nb, map:map, desc:desc, $	 	interleave:interleave, type:type}end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Sets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro setsandHdr, info, fname	envi_setup_head, fname=fname, ns=info.ns, nl=info.nl, nb=info.nb, $		interleave=info.interleave, data_type=info.type, $		descrip=info.desc, map_info=info.map, /writeend	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	returns true if these files can not be used together;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function badFiles, sinfo, linfo	if sinfo.ns eq -1 or linfo.ns eq -1 then begin		print, 'ERROR opening .hdr file'		return, 1	endif	if (sinfo.map).ps(0) ne (linfo.map).ps(0) then begin		print, 'ERROR pixel sizes are not the same, ',sinfo.name,' ',linfo.name		return, 1	endif	if (sinfo.map).ps(1) ne (linfo.map).ps(1) then begin		print, 'ERROR pixel sizes are not the same, ',sinfo.name,' ',linfo.name		return, 1	endif	return, 0end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	finds the smallest bounding box that will enclose both images (in UTM coordinates);;	returns, [top, left, bottom, right];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function combineBounds, sinfo, linfo	bounds=fltarr(4)	smc = (sinfo.map).mc	lmc = (linfo.map).mc		sbot = smc[3] - sinfo.nl*(sinfo.map).ps[1]	lbot = lmc[3] - linfo.nl*(linfo.map).ps[1]		srt = smc[2] + sinfo.ns*(sinfo.map).ps[0]	lrt = lmc[2] + linfo.ns*(linfo.map).ps[0]		bounds(0) = max( [smc[3], lmc[3] ] )	bounds(1) = min( [smc[2], lmc[2] ] )	bounds(2) = min( [sbot, lbot] )	bounds(3) = max( [srt, lrt] )			return, [[bounds], [smc[3],smc[2],sbot,srt], [lmc[3],lmc[2],lbot,lrt]]end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	determines if there is space between the two images being combined;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function extraSpace, bounds, pixSize	if bounds(0,0) ne bounds(0,1) then $		return, (bounds(0,2) - bounds(3,1))/pixSize $	else $		return, (bounds(0,1) - bounds(3,2))/pixSizeend	function overlaploc, bounds	return, bounds(0,0) - bounds(0,1)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	writes the top section of the output image.  only writes the section in which there is;;	no overlap between images, if no such section exists it simply returns;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro fillTop, oun, un, newBounds, info, newns;;if there is no section without overlap just return	if newBounds(0,1) eq newBounds(0,2) then return	lastline = fix(Overlaploc(newBounds[*,1:2])/(info.map).ps(1))			curline=make_array(info.ns, type=info.type)		;;if we need a buffer on one side of the line or the other to fill the space	if newns ne info.ns then begin		linebuffer = make_array(newns - info.ns, type=info.type)	;;if the buffer is on the right side		if newBounds(1,0) eq newBounds(1,1) then begin			for i=0, lastline-1 do begin				readu, un, curline				writeu, oun, curline, linebuffer			endfor	;; else the buffer is on the left side		endif else begin			for i=0, lastline-1 do begin				readu, un, curline				writeu, oun, linebuffer, curline			endfor		endelse;; else we don't need a buffer	endif else begin		for i=0, lastline-1 do begin			readu, un, curline			writeu, oun, curline		endfor	endelse	end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	writes the bottom section of the output image.  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro fillBottom, oun, un, newBounds, info, newns;;if there is no section without overlap just return	if newBounds(2,1) eq newBounds(2,2) then return	lastline = (newBounds(2,1) - newBounds(2,2)) / (info.map).ps(1)	curline=make_array(info.ns, type=info.type)		;;if we need a buffer on one side of the line or the other to fill the space	if newns ne info.ns then begin		linebuffer = make_array(newns - info.ns, type=info.type)	;;if the buffer is on the right side		if newBounds(1,0) eq newBounds(1,2) then begin			for i=0, lastline-1 do begin				readu, un, curline				writeu, oun, curline, linebuffer			endfor	;; else the buffer is on the left side		endif else begin			for i=0, lastline-1 do begin				readu, un, curline				writeu, oun, linebuffer, curline			endfor		endelse;; else we don't need a buffer	endif else begin		for i=0, lastline-1 do begin			readu, un, curline			writeu, oun, curline		endfor	endelse	end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	writes blank lines in between the two images if there is no overlap;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro fillvoid, newun, newBounds, newns, info, nl	if nl gt 100 then begin		line=make_array(newns, 100, type=info.type)		for i=1, nl/100 do begin			writeu, newun, line		endfor	endif	line = make_array(newns, nl mod 100, type=info.type)	writeu, newun, lineend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	This is the "interesting" section.  We will ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro fillOverlap, oun, tun, bun, newBounds, tinfo, binfo	print, 'Sorry, I do not do overlaps yet:('	return	tline = make_array(tinfo.ns, type=tinfo.type)	bline = make_array(binfo.ns, type=binfo.type)	startLap = fix((newBounds(1,1) - newBounds(1,2))/(tinfo.map).ps(0));;if the top map is also the left most	if startLap lt 0 then begin		laplength = fix( (newBounds(0,2) - newBounds(2,1))/(tinfo.map).ps(1) )		startLap = startLap * -1		if laplength lt binfo.nl then begin			fill, oun, tun, bun, tinfo, binfo, lapLength, startLap		endif else $			fill, oun, tun, bun, tinfo, binfo, binfo.nl, startLap	endif else begin		laplength = fix( (newBounds(0,1) - newBounds(2,2))/(tinfo.map).ps(1) )		if laplength lt tinfo.nl then begin			fill, oun, bun, tun, binfo, tinfo, lapLength, startLap		endif else $			fill, oun, bun, tun, binfo, tinfo, tinfo.nl, startLap		endelseendpro fill, oun, lun, bun, linfo, binfo, laplength, startLap	rline = make_array(rinfo.ns, type=rinfo.type)	lline = make_array(linfo.ns, type=linfo.type)	;; a) no EW overlap			if startLap gt linfo.ns then begin				spacerlen=startLap-linfo.ns				spacer = make_array(spacerlen, type=linfo.type)								for i=1, laplength do begin					readu, lun, lline					readu, run, rline									writeu, oun, lline, spacer, rline				endfor;; b) no EW overlap, no EW spacer			endif else if startLap eq linfo.ns then begin				for i=1, laplength do begin					readu, lun, lline					readu, run, rline					writeu, oun, lline, rline				endfor;; c) EW overlap			endif else begin				for i=1, laplength do begin					readu, lun, lline					readu, run, rline										for j=0, startLap-2 do $						writeu, oun, lline(j)					for j=startLap-1,linfo.ns-1 do begin						if lline(j) ne 0 and rline(j+1-startLap) ne 0 then begin							writeu, oun, mean([lline(j),rline(j+1-startLap)])						endif else writeu, oun, lline(j) + rline(j+1-startLap)					endfor					for j=linfo.ns, j=rinfo.ns-1+startLap do $						writeu, oun, rline(j-startLap)				endfor			endelse;;else the bottom map is the left most	endif else	end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Adds image thisMap to fullMap, resizeing fullMap if necessary;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro addToMap, thisMap, fullMap	if not file_test(fullMap) then begin		result=move(thisMap, fullMap, /copy)		setsandHdr, getFileInfo(thisMap), fullMap				return	endif	sinfo=getFileInfo(thisMap)	linfo=getfileInfo(fullMap)	if badFiles(sinfo, linfo) then return	newBounds = combineBounds(sinfo, linfo)	newns = newBounds(3) - newBounds(1) / (sinfo.map).ps(0)	newnl = newBounds(0) - newBounds(2) / (sinfo.map).ps(1)		if newBounds(0,0) eq newBounds(0,1) then begin		topMap = fullMap		tinfo = linfo		botMap = thisMap		binfo = sinfo	endif else begin		topMap = thisMap		tinfo = sinfo		botMap = fullMap		binfo = linfo		newBounds(*,1:2) = [[newBounds(*,2)],[newBounds(*,1)]]	endelse			openw, newun, 'tmpMap', /get	openr, topun, topMap, /get	openr, botun, botMap, /get		fillTop, newun, topun, newBounds, tinfo, newns	spacer = extraspace(newBounds, (sinfo.map).ps(1))	if spacer gt 0 then begin		fillvoid, newun, newBounds, newns, spacer	endif else $		fillOverlap, newun, topun, botun, newBounds, tinfo, binfo, newns;; we must check to see which map reaches the furthest because one map could encompass;;	the other map		if newBounds(2,0) eq newBounds(2,2) then begin		fillBottom, newun, botun, newBounds, binfo, newns	endif else $		fillBottom, newun, topun, newBounds, tinfo, newns					close, newun, topun, botun	free_lun, newun, topun, botun		jnk = move('tmpMap', fullMap)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Read a list of all the files in a directory and add them to a;;	Large map of the entire High plains;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro processMaps	scenes=findfile('*')	print, scenes	fullMap = 'HighPlainsSandMap'		for i=0, n_elements(scenes)-1 do begin		tmp=strsplit(scenes(i), '.', /extract)		if (strtok(scenes(i), '.'))(0) eq 0 and $		tmp(n_elements(tmp)-1) ne 'hdr' and $		scenes(i) ne fullMap then begin			print, '**************************',scenes(i),'**************************'			addToMap, scenes(i), fullMap		endif	endfor	end