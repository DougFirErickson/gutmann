;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Takes a series of lat long coordinates and converts them;;	to UTM Zone 14 coordinates with the builtin envi routine;;	ENVI_CONVERT_PROJECTION_COORDINATES;;;;	convertLLtoUTM wants the first row to be lat, and second row to be lon;;	convertLLtoUTM returns Long. in first column, and Lat. in second column;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function convertLLtoUTM, locations  FORWARD_FUNCTION envi_translate_projection_units, envi_proj_create	s=size(locations)	locations(*,1)=locations(*,1)*(-1)	units=envi_translate_projection_units('Degrees')	iproj=envi_proj_create(/geographic, units=units, datum='WGS-84')	units=envi_translate_projection_units('Meters')	oproj=envi_proj_create(/utm, units=units, datum='WGS-84', zone=14)	envi_convert_projection_coordinates, locations(*,1), locations(*,0), iproj, $						newXmap, newYmap, oproj	map=fltarr(2, n_elements(newXmap))	map(0,*)=newXmap	map(1,*)=newYmap	return, mapend;; takes two column formated text files for latlong and veg.  uses hard coded values for ;;	lat and long to cover entire high plains.  pro krigveg, latlongF, vegF, outF, sz, pow  envistart  !error = 0 & on_ioerror,trouble    if n_elements(outF) eq 0 then outF = vegF+'.map'  if n_elements(pow) eq 0 then pow = 0.5  if n_elements(sz) eq 0 then sz = 0.5    jnk = load_cols(latlongF, tmplldat)if jnk eq -1 then begin print, 'ERROR with Lat Long file' & return & endif   jnk = load_cols(vegF, vegdat)if jnk eq -1 then begin print, 'ERROR with Veg file' & return & endif      lldat=tmplldat   lldat(0,*) = tmplldat(1,*)   lldat(1,*) = tmplldat(0,*)	      index = where(lldat(1,*) lt 110 and lldat(1,*) gt 95 and $                 lldat(0,*) lt 46 and lldat(0,*) gt 30)   ;print, 'There are ', n_elements(index), ' valid points'      if n_elements(vegdat(0,*)) ne n_elements(lldat(0,*)) or n_elements(index) lt 5 then begin      print, string(byte(13)),'Veg Points = ', strcompress(n_elements(vegdat(0,*))), $        'LatLong Points= ', strcompress(n_elements(lldat(0,*)))      return   endif      ;;convertLLtoUTM wants the first row to be lat, and second row to be lon   locations = convertLLtoUTM(transpose(lldat(*,index)))   ;;convertLLtoUTM returns long in first column, and lat in second columne   x = transpose(locations(0,*))   y = transpose(locations(1,*))      bounds = [[46.0,110.0],[30.0,95.0]]		;;boundary of krigged zone in Lat, Long   bounds = convertLLtoUTM(transpose(bounds))   gs = [1000., 1000.]					;;meters / pixel   e=[(bounds(3)-bounds(1))*sz,pow] 		;;same formula as spatCent uses   ;	print, 'Bounds   = ', bounds(*), string(byte(13));	help, x;	help, y;	help, vegdat, string(byte(13))		   flip=0		;; false   if bounds(1) gt bounds(3) then begin      realbounds=bounds      bounds(1) = bounds(3)      bounds(3) = realbounds(1)      flip=1	  ;;true      e=[(bounds(3)-bounds(1))*sz,pow] 		;;need to reset e too   endif   flipy=0		;; false   if bounds(0) gt bounds(2) then begin      realbounds=bounds      bounds(0) = bounds(2)      bounds(2) = realbounds(0)      flipy=1	  ;;true   endif	   print, 'Exponent = ',e;	print, 'rotated x=',strcompress(flip),' New Bounds =', bounds(*);	print, 'y boundary : mean=',mean(y),' max=', max(y),' min=', min(y), string(byte(13));	print, 'x boundary : mean=',mean(x),' max=', max(x),' min=', min(x), string(byte(13))	;   openw, un, outF, /get   openw, un, outF+'.mincurve', /get      for i=0, (size(vegdat))(1) -1 do begin      veg = vegdat(i, index);		print, 'mean=',mean(veg),' max=', max(veg),' min=', min(veg), string(byte(13))      ;		print, x, string(byte(13));		print, y, string(byte(13));		print, transpose(veg), string(byte(13));		print, gs, string(byte(13))      map = min_curve_surf(transpose(veg), x, y, gs=gs, bounds=bounds(*), /double);      map = krig2d(transpose(veg), x, y, gs=gs, bounds=bounds(*), expon=e)      print, 'mean=',mean(map),' max=', max(map),' min=', min(map), string(byte(13))      if flip then map=rotate(map,7)	;;mirrors the image about the x-axis      writeu, un, map      help, map;		print, 100*(i+1.)/(size(vegdat))(1), '% Finished',;		string(byte(13))      errs= n_elements(where(map gt 1 or map lt 0))      print, errs, ' Errors = ', float(errs)/n_elements(map), '%'   endfor   free_lun, un      trouble: if !error ne 0 then print, 'krigveg', !error_stateend