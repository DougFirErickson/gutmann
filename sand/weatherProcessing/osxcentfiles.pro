;ndvi='../climates/ndviimages/newout';;Hack to get around the non-existant HANDLE_VALUE routine! (which seems to exist again now...)function getmapinfo, file	openr, un, /get, file+'.hdr'	s=''	readf, un, s	tmp=str_sep(s, ' ')	while tmp(0) ne 'map' and not eof(un) do begin		readf, un, s		tmp=str_sep(s,' ')	endwhile	free_lun, un	if tmp(0) ne 'map' then return, -1	xoff=0D	yoff=0D	xloc=0D	yloc=0D	px=0D	py=0D		reads, tmp(4),xoff	reads, tmp(5),yoff	reads, tmp(6),xloc	reads, tmp(7),yloc	reads, tmp(8),px	reads, tmp(9),py	;;for compatibility with ENVI map struct put it in	;; these variable names	return, {mc:[xoff,yoff,xloc,yloc],ps:[px,py]}end;;returns topleft(x,y),topright(x,y) in UTM14 coordinatesfunction getBounds, ndvi  info=readENVIhdr(ndvi)  ns=info.ns  nl=info.nl  map=info.map;;written when I thought there was an issue with handle_value on maph;	map=getmapinfo(ndvi)	left = map.mc(2)	top = map.mc(3)	if map.mc(0) ne 1 or map.mc(1) ne 1 then begin		left = left - (map.mc(0)-1)*map.ps(0)		top = top + (map.mc(1)-1)*map.ps(1)	endif	bottom = top - (nl*map.ps(1))	right = left + (ns*map.ps(0))	return, [left, top, right, bottom]end;;enlarge the boundary of bounds by increase meters on all sidesfunction increaseBounds, bounds, increase	newbounds = dblarr(4)	newbounds(0)=bounds(0) - increase	newbounds(1)=bounds(1) + increase	newbounds(2)=bounds(2) + increase	newbounds(3)=bounds(3) - increase	return, newboundsend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Takes a series of lat long coordinates and converts them;;	to UTM Zone 14 coordinates with the ll_to_utm.pro routine;;;;	locations are a float array in decimal degrees [n_pointsx2];;		loc(*,0) = latitude, loc(*,1) = longitude;;;;	return value is float array in UTM14 [2,n_points] x_loc,y_loc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function convertLLtoUTM, locations	;; assuming we are in the western hemisphere and we didn't specify that	;	locations(*,1)=locations(*,1)*(-1)	return, ll_to_utm(locations(*,1),locations(*,0), SetZone=14)endfunction readpoints, keyfile	openr, un, /get, keyfile	s=''	;;read string	readf, un, s	tmp=str_sep(s, ' ')	tmp=tmp(where(tmp ne tmp(2)))	;;convert lat lon strings to decimal degrees	lat=0	reads, tmp(1), lat	min = lat mod 100	lat = lat/100	lat = lat+ float(min)/60.	lon=0	reads, tmp(2), lon	min = lon mod 100	lon = lon/100	lon = lon+ float(min)/60.		utmloc = convertLLtoUTM([[lat],[lon]])	points = {wthpoint, name:tmp(0), xloc:utmloc(0), yloc:utmloc(1),$					lat:lat, lon:lon,start:tmp(3)}	while not eof(un) do begin		readf, un, s		tmp=str_sep(s, ' ')		tmp=tmp(where(tmp ne tmp(2)))		;;convert lat lon strings to decimal degrees		lat=0		reads, tmp(1), lat		min = lat mod 100		lat = lat/100		lat = lat+ float(min)/60.		lon=0		reads, tmp(2), lon		min = lon mod 100		lon = lon/100		lon = lon+ float(min)/60.			utmloc = convertLLtoUTM([[lat],[lon]])		points = [points, {wthpoint, name:tmp(0), xloc:utmloc(0), $					yloc:utmloc(1), lat:lat, lon:lon,start:tmp(3)}]	endwhile	free_lun, un	return, pointsend;;returns true if this point is within the boundaries spec-ed by boundsfunction isInBounds, point, bounds	return, point.xloc lt bounds(2) and $		point.xloc gt bounds(0) and $		point.yloc lt bounds(1) and $		point.yloc gt bounds(3)end;;returns a list of points that fall within boundsfunction inbounds, points, bounds		done=0	i=0	;;find the first valid point;	while not done do begin;		done= isInBounds(points(i), bounds);		i=i+1;	endwhile;	res = i-1	;;find all the rest of the valid points;	for j=i, n_elements(points)-1 do begin;		if isInBounds(points(j), bounds) then begin ;			res=[res,j];		endif;	endfor	return, points;(res)endfunction pickwthfiles, bounds, weather	key=findfile(weather+'*.key')	;print, weather	if n_elements(key) gt 1 then key = weather+'full.key'	if (not (file_test(key))(0)) or (strlen(key))(0) lt 1 then begin 		key=findfile('*.key')		if n_elements(key) gt 1 then key = 'full.key' $		else key = key(0)		if not (file_test(key))(0) then begin			print, 'Could not file weather .key file : ', key			retall		endif	endif		print, weather	points = readpoints(key)	return, inbounds(points,bounds)endpro setuplist100, centbase, outdir	openw, listun, /get, centbase	printf, listun, centbase	printf, listun, centbase	printf, listun, ' '	printf, listun, ' '	printf, listun, 'aglivc'	printf, listun, 'stdedc'	printf, listun, ' '	close, listun	free_lun, listunend		;; returns some basic information about a filefunction nbands, file  info=readENVIhdr(file)	return, info.nbend	;; writes the meta file for spatCent.propro writespatcent, index, points, img, metaname, centdir, dates  openw, oun, /get, metaname  printf, oun, n_elements(index)      for i=0, n_elements(index)-1 do begin    cur=index(i)    lat = fix(points(cur).lat)*100    min = fix(points(cur).lat*100) mod 100    lat = lat + round(min/100. * 60)    lon = fix(points(cur).lon)*100    min = fix(points(cur).lon*100) mod 100    lon = lon + round(min/100. * 60)        printf, oun, (centdir+(str_sep(points(cur).name,'.'))(0)+'.lis '),lat,' ',lon  endfor  printf, oun, img    imgdata=nbands(img)  printf, oun, imgdata  printf, oun, dates    free_lun, ounend;; could be done faster with a hash table but this is easier and fast;; enough :)function pickcrop, c3	if c3 gt 100 then begin		print, 'ERROR, c3=',c3,'... defaulting to CPR...'		crop='CPR'	endif else if c3 lt 0 then begin		print, 'ERROR, c3=',c3,'... defaulting to G5...'		crop='G5'	endif else if c3 lt 37 then begin	crop='G5'	endif else if c3 lt 63 then begin	crop='G3'	endif else if c3 lt 85 then begin	crop='G4'	endif else if c3 le 100 then begin	crop='CPR'		endif else begin		print, 'UNCLASSIFIED C3 =',c3		retall	endelse	return, cropend	;;Converts map positions into image spacefunction coordToimagespace, mapcoords, mapinfo    mapcoords[0]=round((mapcoords[0] - mapinfo.mc[2])/mapinfo.ps[0]) - mapinfo.mc[0]  mapcoords[1]=round((mapinfo.mc[3] - mapcoords[1])/mapinfo.ps[1]) - mapinfo.mc[1]    return, long(mapcoords)end;;Find the C3 percentage from an image of C3 percentagesfunction findc3value, lat, lon, c3map		utmpos=convertLLtoUTM([[lat],[lon]])	        info=readENVIhdr(c3map)        mapinfo=info.map	imgcoords=coordToimagespace(utmpos, mapinfo)        ns=info.ns	print, ' '	c3=0.	openr, un, /get, c3map	point_lun, un, (imgcoords(1) * ns + imgcoords(0))*4	readu, un, c3	close, un	free_lun, un		return, c3*100end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Sets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro setCentHdr, info, fname	info.map.ps = ps	info.ns=windSize[1]	info.nl=windSize[2]	info.type=windSize[3] 	mapinfo=info.map	writeENVIhdr, fname, ns=info.ns, nl=info.nl, nb=info.nb, $		interleave=info.interleave, dtype=info.type, $		ps=mapinfo.ps, zone=14, lat=mapinfo.mc(3), lon=mapinfo.mc(2)end	;; full.key file must be in weather directory, c3c4 must be a float map or c3 distribution;;	with an envi .hdr defining map information.  dates must be a list of dates for ;;	which spatial century maps should be created.  pro osxcentfiles, ndvi,c3c4, wthdir, outdir, nocent=nocent, spatCfile, dates, withSTD=withSTD    if n_elements(wthdir) eq 0 then wthdir = 'Weather'  if n_elements(c3c4) eq 0 then begin    print, 'centfiles, ndvi, c3c4, weatherDir, outputDir, nocent=nocent,spatCfile'    print, '  ndvi = ndvi image with ENVI header'    print, '        used to specify the location'    print, '  c3c4 = %C3 image with ENVI header'    print, '        used to spec CENTURY crop type'    print, '  weatherDir = directory containing'    print, '        CENTURY .wth files (optional, default="Weather")'    print, '  outputDIR = output directory'    print, '  nocent, set this keyword if .lis files exist already'    print, '  spatCfile = spatial output file (optional default="spatCmeta.out")'    print, '         ".out" will be appended to the filename'    return  endif    if n_elements(spatCfile) eq 0 then spatCfile = 'spatCmeta'  ;;uses ENVI to return ndvi image bounds in UTM zone 14 coordinates  bounds=getBounds(ndvi)  if bounds(0) eq -1 then begin    print, 'ERROR with the NDVI file'    return  endif;;allow searches 10Km outside of ndvi image boundary  largebounds = increaseBounds(bounds, 10000)    wthpoints=pickwthfiles(largebounds, wthdir)    if not keyword_set(nocent) then $    openw, oun, /get, 'centbatch'  goodpoints=0    for i=0,n_elements(wthpoints)-1 do begin        if not keyword_set(nocent) then begin      sitename=(str_sep(wthpoints(i).name,'.'))(0)+'.100'      schedname=(str_sep(wthpoints(i).name,'.'))(0)+'.sch'      centbase=(str_sep(wthpoints(i).name,'.'))(0)            cd, wthdir, current=current      dat=wthstat(wthpoints(i).name)      cd, current            c3 = findc3value(wthpoints(i).lat, wthpoints(i).lon, c3c4)      crop = pickcrop(c3)            if dat(0) ne -1 then begin        site100, [dat,wthpoints(i).lat,wthpoints(i).lon],outdir, sitename, c3=c3        sitesch, outdir, sitename,wthdir+wthpoints(i).name,$                 wthpoints(i).start,crop,schedname        print, 'CROP type = ',crop,' ---- C3% = ', c3                cd, outdir, current=currentdir        setuplist100, centbase, outdir        cd, currentdir                printf, oun, 'mv '+outdir+'/'+centbase+'* ./'        printf, oun, 'century -n '+centbase+' -s '+centbase;        printf, oun, 'cp '+outdir+'/'+centbase+'.bin'+' ./'        printf, oun, 'list100 <'+centbase        printf, oun, 'mv '+centbase+'* '+outdir+'/';	printf, oun, 'rm '+outdir+'/'+centbase+'.bin';	printf, oun, 'rm '+outdir+'/'+centbase+'.sch';	printf, oun, 'rm '+outdir+'/'+centbase+'.100'                goodpoints=[goodpoints,i]              endif else print, 'ERROR : ', wthpoints(i).name    endif else if file_test(wthdir+(str_sep(wthpoints(i).name,'.'))(0)+'.lis') then begin      goodpoints=[goodpoints,i]    endif      endfor  if not keyword_set(nocent) then $    free_lun, oun    goodpoints=goodpoints(1:n_elements(goodpoints)-1)    if not keyword_set(nocent) then begin    free_lun, oun    spawn, 'chmod 777 centbatch'    spawn, 'centbatch'  endif  ;  writespatcent, goodpoints, wthpoints, ndvi, spatCfile, wthdir, dates;  spatCent, spatCfile, withSTD=withSTDend		