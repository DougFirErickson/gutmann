;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Gets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getImageInfo, name	      envi_open_file, name, r_fid=id     if id eq -1 then return, {ns:-1, nl:-1, nb:-1}     	envi_file_query, id, ns=ns, nl=nl, nb=nb, h_map=maph,	$		interleave=interleave, data_type=type, descrip=desc	handle_value, maph, mapinfo		envi_file_mng, id=id, /remove		return, {fileInfo, ns:ns, nl:nl, nb:nb, map:mapinfo,		$			interleave:interleave, type:type, desc:desc}end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Sets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro setcombHdr, info, fname, ndviFltToByte=ndviFltToByte, compress=compress	if keyword_set(ndviFltToByte) then $		info.type=1	;we converted float to byte, show this in the header		;note, compress does us no good until ENVI includes it in the setup_head function :(	envi_setup_head, fname=fname, ns=info.ns, nl=info.nl, nb=info.nb, $		interleave=info.interleave, data_type=info.type, $		descrip=info.desc, map_info=info.map, /writeend	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Sets up header info for the new image.  Computes new map Coords, nb, ns, nl;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro setHeader, newinfo, fileInfo, n_images, nb, name, ndviFltToByte=ndviFltToByte, $               compress=compress, thermal=thermal	header = fileinfo		header.ns=newinfo.xend - newinfo.xst	header.nl=newinfo.yend - newinfo.yst        IF NOT keyword_set(thermal) AND nb EQ 7 THEN BEGIN           header.nb=6        ENDIF ELSE $          header.nb=nb	;	header.desc = string(dates(0));	for i=1, n_elements(dates)-1 do begin;		header.desc = header.desc + string(dates(i));		if i+1 mod 3	eq 0 then header.desc = header.desc+ string(byte(10)) ;10=newline;	endfor	header.map.mc(0) = 0	header.map.mc(1) = 0	header.map.mc(2) = fileInfo.map.mc(2) + (newinfo.xst * fileInfo.map.ps(0))	header.map.mc(3) = fileInfo.map.mc(3) - (newinfo.yst * fileInfo.map.ps(1))        header.interleave = 0		setcombHdr, header, name, ndviFltToByte=ndviFltToByte, compress=compressend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Reads the number of images we will concatenate;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getNumberOfImages, unit	 nimg=0	 readf, unit, nimg;	 print, nimg	 return, nimgend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Reads the names of the images we will concatenate;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getImageNames, unit, nimgs	 names=strarr(nimgs)	 tmp=''	 for i=0, nimgs-1 do begin	     readf, unit, tmp	     names(i)=tmp	 endfor	 return, namesend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Gets envi header info (map and ns, nl, nb, type, interleave);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getImagesInfo, names, nimgs	 	 for i=0, nimgs-1 do begin	     tmp=getImageInfo(names(i))		if tmp.ns eq -1 then begin			print, 'ERROR opening file:', names(i)			retall		endif	     if n_elements(list) ne 0 then begin			list=[[list], [tmp]]	     endif else list=[tmp]	endfor	return, listend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Calculates the nest offsets and the minimum ns, nl.  returns the x,y,ns,nl;;	changes necessary for each file;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function calcReSizeInfo, filesInfo, nimgs	 xsts=lonarr(nimgs)	 ysts=lonarr(nimgs)	 xend=lonarr(nimgs)	 yend=lonarr(nimgs)	 	 xsz = filesInfo(0).map.ps(0)	 ysz = filesInfo(0).map.ps(1)	 for i=0, nimgs-1 do begin	     xsts(i) = filesInfo(i).map.mc(2) - (filesInfo(i).map.mc(0))*xsz	     xend(i) = xsts(i) + (filesInfo(i).ns*xsz)	     ysts(i) = filesInfo(i).map.mc(3) + (filesInfo(i).map.mc(1))*ysz	     yend(i) = ysts(i) - (filesInfo(i).nl*ysz)	 endfor	 minx=max(xsts)	 miny=min(ysts)	 maxx=min(xend)	 maxy=max(yend)	 newns=fix((maxx-minx)/xsz)	 newnl=fix((miny-maxy)/ysz);	 print, 'minx,   miny,   maxx,   maxy';	 print, minx, miny, maxx, maxy	 print, 'newns, newnl'	 print, newns, newnl	 tmp={newsize, xst:0, yst:0, xend:0, yend:0}	 newsizes=replicate(tmp, nimgs)	 for i=0, nimgs-1 do begin	     newsizes(i).xst=(minx - xsts(i)) / xsz	     newsizes(i).yst=(ysts(i) - miny) / ysz	     newsizes(i).yend= newsizes(i).yst + newnl	     newsizes(i).xend= newsizes(i).xst + newns	 endfor;	 print, newsizes	 return, newsizesend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Combines lots and lots of images of unequal sizes into one file of equal size;;	could also be modified to make them all the same size;;;;	Currently subsets the images to the x,y offset of 0,0 and ns, nl is obviously;;	the smallest value;;;;	metafile should be ascii;;		number of images;;		image file names (seperate lines) images must have envi header;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro combunequal, meta, outfile, ndviFltToByte=ndviFltToByte, $                 compress=compress, split=split, thermal=thermalenvistartif n_elements(outfile) eq 0 then outfile=string(meta, '.out')openr, metaun, /get, metanimgs=getNumberOfImages(metaun)names=getImageNames(metaun, nimgs)close, metaun	& free_lun, metaun;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;this is where we do most of the interesting stufffileInfo=getImagesInfo(names, nimgs)if n_elements(fileInfo) lt 2 then begin   print, 'ERROR, you need more than 1 image'   print, fileInfo   retallendifupdateInfo=calcReSizeInfo(fileInfo, nimgs)print, updateInfo ;, fileInfoprint, 'Combining files...'originalout = outfileif keyword_set(split) then begin   	outfile = strcompress(string(originalout+'1'), /remove_all)endifif keyword_set(compress) then begin	openw, oun, /get, outfile, /compressendif else openw, oun, /get, outfilefor i=0, nimgs-1 do begin    openr, un, /get, names(i)    info=fileInfo(i)    newsize=updateInfo(i);; could be made much faster by reading 1/4 of each band rather than 1 line at a time.    line=make_array(info.ns, info.nl, type=info.type)    for j=0, info.nb-1 do begin;    for k=0, info.nl-1 do begin              if keyword_set(ndviFltToByte) then begin          line=make_array(info.ns, info.nl, type=info.type)          readu, un, line          line=fix(line*255)          index = where(line lt 0)          if index(0) ne -1 then $            line(index) = 0          line=byte(line)       ENDIF ELSE $         readu, un, line       ;	if ((k ge newsize.yst) and (k lt newsize.yend)) then $       IF ((info.nb NE 7) OR (j NE 5) OR (keyword_set(thermal))) THEN $           writeu, oun, line(newsize.xst:newsize.xend-1, $                             newsize.yst:newsize.yend-1);    endfor    endfor    close, un	& free_lun, un    if keyword_set(split) and i ne nimgs-1 then begin       close, oun & free_lun, oun       setHeader, updateInfo(i), fileInfo(i), 1, info.nb, outfile, ndviFltToByte=ndviFltToByte, compress=compress       outfile = strcompress(string(originalout+string(fix(i+2))), /remove_all)       if keyword_set(compress) then begin          openw, oun, /get, outfile, /compress       endif else openw, oun, /get, outfile    endif endfor  close, oun	& free_lun, oun i=nimgs-1 if keyword_set(split) then begin    nimgs=1    setHeader, updateInfo(i), fileInfo(i), nimgs, info.nb, outfile, ndviFltToByte=ndviFltToByte, thermal=thermal endif else $   setHeader, updateInfo(0), fileInfo(0), nimgs, nimgs, outfile, ndviFltToByte=ndviFltToByte, thermal=thermalend