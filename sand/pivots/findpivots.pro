;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; moderate sobel edge in green = 30, nir=30, ndvi=100function checkPointFull, ndvi, img, edgemap, filter, penalty	;;filter is ?*3*2	h=size(ndvi) &	ns = h(1) &	nl = h(2)	h=size(filter) 	&	n=h(1)	newedgemap=edgemap		totalmisses = 0l &	totalhits=0l &	currentmisses=0l &	currenthits=0l	bigmisses=0l;	x=intarr(3);	y=intarr(3)	;;loop through the entire circle filter	for i=0, n-1 do begin		x=filter(i,*,0)				y=filter(i,*,1);;if we have already found this edge don't do anything		if newedgemap(x(1),y(1)) eq 20 then begin		endif $		;;if we found a nice edge in the first location		else if edgemap(x(1),y(1)) eq 10 and edgemap(x(0),y(0)) eq 0 then begin			totalhits=totalhits+1			currenthits=currenthits+1			if currentmisses gt 1 then currentmisses=0			newedgemap(x(1),y(1)) = 20		endif $		;;if we found a nice edge in the second location		else if edgemap(x(2),y(2)) eq 10 and edgemap(x(1),y(1)) eq 0 then begin			totalhits=totalhits+1			currenthits=currenthits+1			if currentmisses gt 1 then currentmisses=0			newedgemap(x(1),y(1)) = 20		endif $;;else, we couldn't find a proper edge		else begin			totalmisses=totalmisses+1			currentmisses=currentmisses+1			if currentmisses gt 4 then currenthits=0			if currentmisses gt 3 and currenthits ne 0 then bigmisses=bigmisses+1			newedgemap(x(1),y(1)) = 20		endelse		;;mark this edge as found already;		if currenthits gt 0 then newedgemap(x(1), y(1))=20	endfor	return, fix(totalhits-totalmisses-(penalty*bigmisses))end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function dist, a, b	a=float(a)	return, sqrt(float((a(0)-b(0))^2) + (a(1)-b(1))^2)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function find_point_at_dist_rad, center, dist, angle	x=byte(center(0) + (cos(angle) * dist))	y=byte(center(1) + (sin(angle) * dist))	return, [x,y]end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function createEdgeSearch, size	nsrchs=size*4		;;this is the number of angles we will search around the circle	filter=bytarr(nsrchs, 3, 2)	;;the filter will store three x,y locations in a line from				;; the center	d=size/2	cx=(size/2)+1	cy=(size/2)+1	radIncrement = (2.*!PI)/nsrchs	for i=0, nsrchs-1 do begin		loc=find_point_at_dist_rad([cx, cy], d-1, (radIncrement*i))		filter(i, 0, *)=loc		loc=find_point_at_dist_rad([cx, cy], d, (radIncrement*i))		filter(i, 1, *)=loc		loc=find_point_at_dist_rad([cx, cy], d+1, (radIncrement*i))		filter(i, 2, *)=loc	endfor	return, filterend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function initSearch, ndvi, threshold, size	h=size(ndvi)	ns = h(1)	nl = h(2)	halfsize=(size+6)/2	circles=intarr(ns, nl);; first order search that tells us where to look more closely;; quarter circle should be about 175 pixels, half=350, full=700	for i=halfsize, ns-halfsize-1 do begin	for j=halfsize, nl-halfsize-1 do begin		lowx=i-halfsize+2 & hix=i+halfsize-1		lowy=j-halfsize+2 & hiy=j+halfsize-1		circles(i,j) = n_elements(where(ndvi(lowx:hix, lowy:hiy) ge threshold))	endfor	endfor	return, circlesend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function createNDVIbyte, img	h=size(img)	ns = h(1)	nl = h(2)	tmpndvi=fltarr(ns, nl)	tmpndvi=(Float(img(*,*,3))-img(*,*,2))/(Float(img(*,*,3))+img(*,*,2))	if max(tmpndvi) gt 1 then $		tmpndvi(where(tmpndvi gt 1)) = 1	if min(tmpndvi) lt 0 then $		tmpndvi(where(tmpndvi lt 0)) = 0	ndvi=bytarr(ns, nl)	ndvi=byte(tmpndvi*255)	tmpndvi=bytarr(1)	return, ndviend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function findALLedges, ndvi, img, ndvithresh, imgthresh	h=size(img)	ns=h(1)	nl=h(2)	nb=h(3)	sob=sobel(ndvi)	sobf=intarr(nl,ns,nb)	for i=0, nb-1 do begin		tmp=sobel(img(*,*,i))		sobf(*,*,i) = tmp	endfor	;tvscl, sobf(*,*,1)	tmp = bytarr(1)	edgemap=bytarr(ns, nl)	edgemap(where(sob ge ndvithresh)) = 10	edgemap(where(sobf(*,*,0) ge imgthresh)) = 10	edgemap(where(sobf(*,*,1) ge imgthresh)) = 10	edgemap(where(sobf(*,*,2) ge imgthresh)) = 10	return, edgemapend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function make_circle_filter, size	nsize=fix(size+5)	newfilter=intarr(nsize, nsize)	for i=0, nsize-1 do begin		for j=0, size-1 do begin			d=(fix(dist([i,j],[nsize/2, nsize/2])) - nsize/2)			if d le -2 then $				newfilter(i,j)=-1		endfor	endfor	return, newfilterend;make_circle_array;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function findcenters, map, threshold	index = where(map gt threshold)	ns = (size(map))(1)		x = index mod ns	y = index / ns		return, transpose([[x],[y]])end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	returns a list of image locations;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function getCenters, map, threshold		newmap = map	search = 10	windowSize = (search*2) +1	ns = (size(map))(1)	belowThresh = threshold - 100;	index = where(newmap lt -150);	newmap(index) = -150		index = where(newmap gt threshold)	;;if no where in the image is registered as a pivot then quit	if index(0) eq -1 then return, 0		for i=0l, n_elements(index)-1 do begin						x = index(i) mod ns		y = index(i) / ns				windowmax = max(newmap(x-search:x+search,y-search:y+search)) 		windowindex = where(newmap(x-search:x+search,y-search:y+search) eq windowmax);;If the current point is not the maximum in the window set it below the threshold		if newmap(index(i)) lt windowmax then begin			newmap(index(i)) = belowThresh;;check for multiple points with the maximum value in a region		endif else if n_elements(windowindex) gt 1 then begin			for j=1, n_elements(windowindex)-1 do begin				tmpx = x - search + (windowindex(j) mod windowSize)				tmpy = y - search + (windowindex(j)  /  windowSize)								newmap(tmpx,tmpy) = belowThresh			endfor		endif	endfor	return, findcenters(newmap, threshold)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;pro findpivots, imgF, outF, ns, nl, nb, pivotfile, search_size=search_size, penalty=penalty, $	edgethresh=edgethresh, ndvi=ndvi;;searches for standard (~25? pixel diameter) crop circles	if not keyword_set(search_size) then search_size=25	if not keyword_set(edgethresh) then edgethresh = 20	if not keyword_set(penalty) then penalty = 1	;; reads in the image file, for now we will assume we can read the entire img at once;;	also assumes byte bsq files	openr, iun, /get, imgF 	img=bytarr(ns,nl,nb) &	readu, iun, img	close, iun &			free_lun, iun	openw, oun, /get, outF	if not keyword_set(ndvi) then ndvi=createNDVIbyte(img) else ndvi = img	halfsize=(search_size+6)/2	filter=createEdgeSearch(search_size)	centerfilter=make_circle_filter(search_size)	othermap=lonarr(ns, nl)	;;initial search to minimize the number of places we need to search in the end;	circles=initSearch(ndvi, 100, search_size)	;;initially using 125;	quartercirclearea=fix(!pi*(halfsize^2)/4);	print, 'quarter circle area=', quartercirclearea;	full_Index=where(circles gt quartercirclearea)	othermap(0:(halfsize+1), *) = 1	othermap(ns-(halfsize+2):ns-1, *) = 1	othermap(*, 0:halfsize+1) = 1	othermap(*, nl-(halfsize+2):nl-1) = 1	full_Index = where(othermap eq 0)	othermap(*,*) = 0	full_Size=n_elements(full_Index)	edgemap=findALLedges(ndvi, img, edgethresh*10, edgethresh*3)	newmap=make_array(ns, nl, type=2, value=-1000)	markerinterval= full_Size /10	tmpmark=0						for i=0l, full_Size-1 do begin		x=(full_Index(i) mod ns)-1 &	y=(full_Index(i)  /  ns)-1		xlow=x-halfsize+1 & xhi=x+halfsize 	   &	ylow=y-halfsize+1 & yhi=y+halfsize				newmap(full_Index(i)) = checkPointFull( ndvi(xlow:xhi, ylow:yhi),	$			img(xlow:xhi, ylow:yhi, *),		$			edgemap(xlow:xhi, ylow:yhi, *),		$			filter, penalty)				if i/markerinterval gt tmpmark then begin			tmpmark=i/markerinterval			print, strcompress(tmpmark*10, /remove_all) + '%'		endif		othermap(full_Index(i))=total(edgemap(xlow:xhi, ylow:yhi) * centerfilter)	endfor	;; used if we are only searching areas that have a high NDVI;	i=min(newmap(where(newmap ne -1000)));		;	newmap(where(newmap eq -1000)) = i-10		newmap=temporary(newmap)+(othermap/100) ;;this subtracts for any internal edges	writeu, oun, fix(newmap)	close, oun	&	free_lun, oun	openw, locun, /get, pivotfile	printf, locun, getCenters(newmap, edgethresh)	close, locun	&	free_lun, locunend;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;