;; finds the angle from point a to point bfunction findAngle, a,b	xDist = b(0) - a(0)	yDist = b(1) - a(1)	angle = (360./(2*!pi)) * atan(abs(float(yDist)), abs(xdist))		if xDist lt 0 then begin		if yDist lt 0 then begin			angle=angle+180		endif else if yDist eq 0 then begin			angle = 180		endif else begin			angle = 180 - angle		endelse			endif else if xDist eq 0 then begin		if yDist lt 0 then begin			angle = 270		;endif else if yDist eq 0 then begin		;	print, 'ERROR, duplicate points, ', strcompress(a), strcompress(b)		;	print, 'Angle = ', strcompress(angle)		endif else begin			angle = 90		endelse			endif else begin		if yDist lt 0 then begin			angle = 360 - angle		endif else if yDist eq 0 then begin			angle = 0		endif else begin			angle = angle		endelse			endelse												return, angleend;;screws up 0 for 180 and 90 for 270?function oldfindAngle, a,b	xDist = b(0) - a(0)	yDist = b(1) - a(1)	angle = (360./(2*!pi)) * atan(abs(float(yDist)), abs(xdist))	if yDist lt 0 then $		angle = 360+angle		return, angleendpro eraseline, start, tmpangle, dist	angle = (tmpangle/double(360))*2*!pi	finish = intarr(2)	finish(0) = start(0) + round(dist*cos(angle))	finish(1) = start(1) + round(dist*sin(angle))		x = [start(0),finish(0)]	y = [start(1),finish(1)]		plots, x,y,linestyle=0, color=0, /deviceendpro plotline, start, tmpangle, dist	angle = (tmpangle/double(360))*2*!pi	finish = intarr(2)	finish(0) = start(0) + round(dist*cos(angle))	finish(1) = start(1) + round(dist*sin(angle))		x = [start(0),finish(0)]	y = [start(1),finish(1)]		plots, x,y,linestyle=0, /deviceend;;Polygon should be an array of vertices in X,Y space ;;;;	if the vertices are in counterclockwise order then ;;	this is an internal polygon.;;	return, true;;;;  If the vertices are stored in clockwise order than;;	this is an external polygon;;	return, false;;function isInternal, polygon		oldpoint = polygon(*,1)	lastAngle = findAngle(polygon(*,0),oldpoint)	totAngle = 0.		firstpoint = polygon(*,0)	;	angles = fltarr(3,n_elements(polygon(0,*)))	length = 25	xcompass = 300	xword = 350	ycur = 50	ynew = 125	ytot = 200		drawingpolygon = polygon	drawingpolygon(0,*) = 1000*(polygon(0,*) - min(polygon(0,*))) / max(polygon(0,*))	drawingpolygon(1,*) = 1000*(polygon(1,*) - min(polygon(1,*))) / max(polygon(1,*))	;	window, xsize=1000,ysize=1000;	xyouts, xcompass,ytot+25, 'Total Angle', /device;	xyouts, xcompass,ynew+25, 'New Angle', /device;	xyouts, xcompass, ycur+25, 'Change Angle', /device	lastcur=fltarr(10)	lastnew=fltarr(10)		for i=2, n_elements(polygon(0,*))-1 do begin		nextpoint = polygon(*,i)				newAngle = findAngle(firstpoint, nextpoint);		oldnewangle= oldfindangle(oldpoint, nextpoint);		if oldnewangle ne newangle then begin;			print, oldnewangle, newangle;			print, oldpoint, nextpoint;		endif		curAngle =  newAngle - lastAngle		if curAngle gt 180 then begin			curAngle = (360 - curAngle) * (-1)		endif else if curAngle lt -180 then begin			curAngle = (-360 - curAngle) * (-1)		endif		totAngle = totAngle + curAngle		lastAngle = newAngle		oldpoint = nextpoint				lastcur(i mod 10) = curAngle		lastnew(i mod 10) = newangle		curangle = mean(lastcur)		newangle = mean(lastnew)		;		plots, drawingpolygon(*,i-2:i), /device;		plotline, [xcompass,ytot],totangle, length;		xyouts, xword,ytot,totangle, /device;		plotline, [xcompass,ycur],curangle, length;		xyouts, xword,ycur,curangle, /device;		plotline, [xcompass,ynew],newangle, length;		xyouts, xword,ynew,newangle, /device	;	wait, 0.1;		eraseline, [xcompass,ynew],newangle, length;		xyouts, xword,ynew,newangle, /device, color=0;		eraseline, [xcompass,ytot],totangle, length;		xyouts, xword,ytot,totangle, /device, color=0;		eraseline, [xcompass,ycur],curangle, length;		xyouts, xword,ycur,curangle, /device, color=0;		angles(0,i) = curAngle;		angles(1,i) = totAngle;		angles(2,i) = newAngle			endfor;	wdelete	;	print, 'Final Angle = ', totAngle;	if totAngle gt 0 then print, 'Is Internal';	return, angles	;	if n_elements(polygon(0,*)) gt 20 then begin	;	drawslow, polygon	;		if totAngle gt 0 then XYouts, 200,450,'This Is an Internal Polygon', /device $;		else XYouts, 200,475,'This Is an EXTERNAL Polygon' , /device;		xyouts, 200,500,'totangle='+strcompress(totangle), /device;		wait, 2;	endif;	wdelete	return, (totAngle lt 0)endfunction isExternal, polygon	return, not isInternal(polygon)end;function allXYs;	;	points=fltarr(2,361);	;	angles = indgen(361);	angles = angles * (2*!pi)/360.;	;	for i=0, 360 do begin;		points(0,i) = cos(angles(i));		points(1,i) = sin(angles(i));	endfor;	return, points;end;;function reverse, poly;	tmp = poly;	sz = n_elements(poly(0,*));	;	for i=0, sz-1 do begin;		tmp(*,sz-i-1) = poly(*,i);	endfor;	return, tmp;end		