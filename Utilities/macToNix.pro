pro descprint,';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;'print,';;'print,';;	Converts all Carriage Returns in a file into'print,';;	Line Feeds.  (ascii 13 to ascii 10)'print,';;'print,';;	USAGE = macToNix, inputfile, outputfile, safe=safe, dir=dir'print,';;		inputfile  =  self evident'print,';;		outputfile =  self evident'print,';;		safe = keyword not commonly used.  It will alert you if'print,';;			the output filename already exists'print,';;	'print,';;	'print,';;	Useful because macs still use CR, while *nix'print,';;	uses LF.  But it also uses some neat routines'print,';;	to find a currently non-existant file extension'print,';;	and to move a file from one name to another'print,';;'print,';;	Takes an input file name and an output filename'print,';;	if the keyword /safe is set it will search for'print,';;	an output file name that does not already exist'print,';;	to ensure it does not overwrite a file'print,';;'print,';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;'end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Finds a unique file extension that does not exist;;	In the current working directory;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function findUnique, seed	if n_elements(seed) eq 0 then $		seed=1234l	tmpend = round(abs(randomn(seed) * 100))	while (findfile('*.'+strcompress(tmpend, /remove_all)))(0) ne '' do $		tmpend = round(abs(randomn(seed) * 100))	if tmpend lt 100 then $		tmpend = '0'+strcompress(tmpend, /remove_all)	return, strcompress(tmpend, /remove_all)end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Moderately useful function to move a file named in;;	to a file named out.  ;;;;	returns -1 on error, returns 0 on proper exit;;;;	NOTE : it is much faster to do this via the OS ;;	which can rename a file, but this routine is;;	portable to any OS... no spawning?;;;;	ALSO : if the keyword copy is not set it will delete;;	the original file after copying every byte.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function move, in, out, copy=copy, safe=safe	if not file_test(in) then begin		print, in, ' DOES NOT EXIST!'		return, -1	endif	if keyword_set(safe) then $		if file_test(out) then begin			print, out, ' ALREADY EXISTS... oh well'			return, -1		endif			openr, un, /get, in	openw, oun, /get, out		f=fstat(un)	if f.size gt 10000000 then begin		input=bytarr(10000000)		while f.size - f.cur_ptr gt 10000000 do begin			readu, un, input			writeu, oun, input			f=fstat(un)		endwhile	endif	input=bytarr(f.size-f.cur_ptr)	readu, un, input	writeu, oun, input		close, oun, un	free_lun, oun, un		if not keyword_set(copy) then $		file_delete, in	return, 0end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Used to operate on all file in a directory. ;;;;	NOTE : current files will be replaced!!!;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function batchMacToNix, dir, safe=safe, nToMac=nToMac, recurse=recurse	cd, dir, current=current		file_list=findfile('*')	tmpending=findUnique()	for i=0, n_elements(file_list)-1 do begin				if file_test((strsplit(file_list(i),':',/extract))(0), /directory) then begin			if keyword_set(recurse) then $			tmp = batchMacToNix(dir=(strsplit(file_list(i),':',/extract))(0), $					safe=safe, nToMac=nToMac, recurse=recurse)		endif else begin			out=file_list(i)+tmpending			in = file_list(i)					if keyword_set(nToMac) then begin				if nixToMac(in, out) eq -1 then begin					print, 'ERROR converting file ', in					print, 'File left untouched'				endif			endif else begin				if macToNix(in, out) eq -1 then begin					print, 'ERROR converting file ', in					print, 'File left untouched'				endif			endelse					if move(out, in, safe=safe) eq -1 then begin				print, 'ERROR moving file ', out, ' to file ', in				print, 'Files left untouched'			endif		endelse		print, in		print, ''		endfor		cd, current	return, 0end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Main Routine, does as header states;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function macToNix, infile, outfile, safe=safe, dir=dir, recurse=recurse		if keyword_set(dir) then return, batchMacToNix(dir, safe=safe)	if n_elements(outfile) eq 0 then begin		desc		return, -1	endif	if not file_test(infile) then begin		print, infile,' does not exist!'		return, -1	endif	if file_test(outfile) then begin		print, 'WARNING, OVERWRITING FILE : ', outfile 		if keyword_set(safe) then $			outfile=outfile+'.'+findUnique()	endif		openr, un, /get, infile	openw, oun, /get, outfile		nextchar=0b	;;Search through the file replacing CR with LF	f=fstat(un)	if f.size gt 10000000 then begin		input=bytarr(10000000)		while f.size - f.cur_ptr gt 10000000 do begin			readu, un, input			index=where(input eq 13)			if index(0) ne -1 then $				input(index) = 10			writeu, oun, input			f=fstat(un)		endwhile	endif else if f.size eq 0 then begin		print, 'ERROR : ', infile, ' has no data'		print, 'Filesize = ', f.size		close, oun, un		free_lun, oun, un		return, -1	endif		if f.size ne f.cur_ptr then begin		input=bytarr(f.size-f.cur_ptr)		readu, un, input		index=where(input eq 13)		if index(0) ne -1 then $			input(index) = 10		writeu, oun, input	endif		close, oun, un	free_lun, oun, un	return, 0end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Main Routine, does as header states;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;function nixToMac, infile, outfile, safe=safe, dir=dir, recurse=recurse		if keyword_set(dir) then return, batchMacToNix(dir, safe=safe, /nToMac)	if n_elements(outfile) eq 0 then begin		desc		return, -1	endif	if not file_test(infile) then begin		print, infile,' does not exist!'		return, -1	endif	if file_test(outfile) then begin		print, 'WARNING, OVERWRITING FILE : ', outfile 		if keyword_set(safe) then $			outfile=outfile+'.'+findUnique()	endif		openr, un, /get, infile	openw, oun, /get, outfile		nextchar=0b	;;Search through the file replacing CR with LF	f=fstat(un)	if f.size gt 10000000 then begin		input=bytarr(10000000)		while f.size - f.cur_ptr gt 10000000 do begin			readu, un, input			index=where(input eq 10)			if index(0) ne -1 then $				input(index) = 13			writeu, oun, input			f=fstat(un)		endwhile	endif else if f.size eq 0 then begin		print, 'ERROR : ', infile, ' has no data'		print, 'Filesize = ', f.size		close, oun, un		free_lun, oun, un		return, -1	endif		if f.size ne f.cur_ptr then begin		input=bytarr(f.size-f.cur_ptr)		readu, un, input		index=where(input eq 10)		if index(0) ne -1 then $			input(index) = 13		writeu, oun, input	endif		close, oun, un	free_lun, oun, un	return, 0end