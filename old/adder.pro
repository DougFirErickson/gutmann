pro adder, fileName, columns, rows, bands;; Name:;	adder;; Purpose:;	Designed to output "spectra" of the average dn values across a;	row, with the rows taken at various angles through out the image.  ;	requires that the ;; Calling Sequence:;	adder, filename;; Parameters:;	filename	name of image file to be processed.  ;			header file fileName.hdr must also be present;; Keywords:;	none;; Common Blocks:;	none; SIDE EFFECTS:;	none;; RESTRICTIONS:;	none;; COMMENTS:;; MODIFICATION HISTORY:;	created 10/21/99	EDG;;;;	Commented section could be fixed up to read samples, lines, and bands;;	from header file instead of from the command line.  ;;	if header file cannot be found read from stdin;;headerFile = STRING(fileName, ".hdr");hder = READ_ASCII(headerFile);;;eol = STRPOS(hder, '\nl');sampTxt = STRMID(hder, 10,  (eol-10));;nexteol = STRPOS(hder, '\nb');nexteol = ;lineTxt = STRMID(hder, (eol+11), (nexteol-(eol+11)));;eol = STRPOS(hder, '\nh');bandTxt = STRMID(hder, (nexteol+11), (eol-(nexteol+11)));;print, sampTXT;print, lineTXT;print, bandTXT;read, columns, Prompt='Input # of Samples: ';read, rows, Prompt='Input # of Lines: ';read, bands, Prompt='Input # of Bands: '	;;can be used to use images, must 						;; also change to byte data;this is the file we will print the output too, for later use in idloutfile = String(filename, ".add")openw, 2, outfilecurline = bytarr(columns);;for now the program won't go past a 45 degree angle, so we can only;; draw a "line" from (0,0), to (min, min), it is easy to write a script that will;; rotate an image 90 degrees, so you can do this, then run this program again.  if rows lt columns	then	minDim = rows	else minDim = columnsarrsize = floor(mindim*1.5);header to output file is the number of "spectrum" = mindim*1.5 = arrsizewriteu, 2, arrsize;;arrays to hold the output data, make them 2x minDim, so that we can hold;; at least the (sqrt(2)*minDim) data points necessary for a 45 degree angleave = bytarr(arrsize)delAngl = floor(mindim/1000);;step through all possible angles.for angle=0, (minDim-1), delAngl do begin	sum = replicate(0L, arrsize)	numPix = replicate(0, arrsize)	openr, 1, fileName		;;open it each time because we need to read through					;; the whole file for each angle	delX = float(angle)/columns		;;given(angle le mindim), thus(delx ge 1);;this is no longer used because we are using a float delx;;	LastX = columns mod (angle+1)		;; what ever is left over only for debug	for i=0,(rows-1) do begin 		;;steps through every row of the image		readu, 1, curline		;; current horizontal line to work with	;;point in data arrays to start at, we will work up section on each line, 	;; so start down a few.  this is why angle starts at 0 instead of 1		start = i+angle		curpos = byte(start)	;;beause rotated rows are angled down to the right, as we move across a horizontal	;; row of pixels, we must keep moving up lines in the rotated array, one every 	;; delX pixels.	;;add delX pixels to sum array[x] then move up to then add delX pixels	;; to sum[x-1] (the next line up)		for j=0, (columns-1) do begin			if curline[j] ne 0 then begin				sum(curpos) = sum(curpos)+curline[j]				numPix(curpos) = numPix(curpos) + 1			endif			start = start - delX			curpos = round(start)		endfor	endfor	print, "Angle = ", angle, " finished"	ave = byte(round(sum/numPix))	writeu, 2, ave	close, 1endforclose, 2end