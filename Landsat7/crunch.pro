pro crunch; This program takes dark object subtracted Landsat 5 imagery; and converts it to radiance and reflectance based on cross calibration; and normalization values derived earlier.;; Program asks you to select the file that you want to conver to; radiance and reflectance; 		File name must be PPRR-YY-dos format;			where PPRR is the path row;			and YY is the two digit year for the image;; The file table.txt must be found and loaded into an array by the; code, change the load_cols line as necessary.  This table contains; the sun data and normaliztion values that will be used;; It will create two seperate images in the same directory; the original file was located in, one radiance and one reflectance;; The radiance image will be named:;		PPRR-YY-radiance; The reflectance image will be name:;		PPRR-YY-reflectance;; written by Eric Johnson and Peter Gimeno; 25 August 2000; updated 30 August 2000; Brings up GUI to select input file, also changes; directory to the directory that the input file is inprint, '!!!! Image must be bands 1-5 and 7 and dark object subtracted !!!!'print, 'Select the image you want to convert to reflectance'  infile = DIALOG_PICKFILE(/READ, FILTER = '*',GET_PATH = img_path)  openr, un1, /get, string(infile)  cd, string(img_path)  print, string(infile); Opens the DN image file in ENVI to read the samples, lines and bandsfname = string(infile)envi_open_file, fname, r_fid=fidif (fid ne -1) then $  envi_file_query, fid, ns=ns, nl=nl, nb=nb	dn_img = bytarr(ns); Strips the input filename from the pathstill_not_done = strpos(string(infile),'\')while (still_not_done ne -1) do begin  for i=0,still_not_done do $    strput, infile, ' ', i  infile = strtrim(infile,2)  still_not_done = strpos(string(infile),'\')endwhile; Strips the path/row and year from the input file namepathrow = strmid(infile,0,4)year = strmid(infile,5,2); loads in date and sun elevation data for selected path/row and year; this code must be able to locate the sun_elev.txt fileprint, load_cols('D:\Base 96 L5 Images\table.txt', sun)	prtemp = 1 ;sets the prtemp to a nonusable value;loops through the text file to select the record	for i=0,32 do begin	  prtemp = sun(0,i)	  if (fix(prtemp) eq fix(pathrow)) then line = i	endfor;gets month, day and sun elevation for 1985 imagery	if (year eq '85') then begin $	 day = fix(sun(2, line))	 month = fix(sun(3, line))	 elevation = sun(1, line)	 zenith = 90 - elevation	 norm = 1 ;sets flag for normalization 1-yes 0-no	endif;gets month, day and sun elevation for mid year imagery	if (year eq '88') or $	   (year eq '89') or $	   (year eq '94') then begin $	  day = fix(sun(5, line))	  month = fix(sun(6, line))	 elevation = sun(4, line)	 norm = 1  ;sets flag for normalization 1-yes 0-no	 zenith = 90 - elevationendif;gets month, day and sun elevation for 1996 imagery	if (year eq '96') then begin $  	day = fix(sun(8, line))  	month = fix(sun(9,line)) 	elevation = sun(7,line)	 zenith = 90 - elevation	 norm = 0  ;sets flag for normalization 1-yes 0-no	endif; all this was a test to see if the code was working right; prints out the path/row, date and, sun data and julain date;print, 'Path\Row :', fix(pathrow);print, 'Year: ',fix(year+1900);print, 'Month: ', month,'   Day: ', day;print, 'sun elevation: ', elevation;print, 'sun zenith: ', zenith;print, ' ';print, sun(*, line)print, ' '; this calculates the julian date for the path/row and year selected; the julian date is stored in varable 'jday'; julian date is never used in this code so don't worry about this partjulain_days = [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]if (month eq 1) then jday = day $else jday = julain_days(month-2) + dayif ((((year+1900) mod 4) eq 0) and (month gt 2)) then jday = jday + 1;print, 'The Julian date is: ',jday; Sensor Gain for most images in the project; All bands set to high and band 4 set to lowgain = [[-6.2, 191.6], $ ; Band 1: (LMin, LMax)       [-6.4, 196.5], $  ; Band 2: (LMin, LMax)       [-5.0, 152.9], $  ; Band 3: (LMin, LMax)       [-5.1, 241.1], $  ; Band 4: (LMin, LMax)       [-1.0, 31.06], $  ; Band 5: (LMin, LMax)       [-0.35, 10.80]]   ; Band 7: (LMin, LMax); This statement sets the sensor gain to high for band 4; if the sun elevation angle is less than 45 degreesif (elevation le 45) then gain(*,3) = [-5.1, 157.4]; This section contains the six values which will be used; for the mean solar exoatmoshperic irradianceesun = [1970, 1843, 1555, 1047, 227.1, 80.53]; Cross calibration values Landsat 5 to Landsat 7cross_cal = [0.9039, 1.6745, 1.4725, 1.3686, 1.0039, 1.3490]normalize = fltarr(6) ;6 value array to hold normalization valuesnormalize(*) = 1 ;sets the initial value of normalize to 1; Normalization values pulled for input table for path/row and year	; grabs normalization values for the 85 imagery	if (year eq '85') then begin 		for n = 0,5 do normalize(n, 0) = sun(n+10, line)	endif	;grabs normalization values for the mid year imagery	if (year eq '88') or (year eq '89') or (year eq '94') then begin 		for p = 0,5 do normalize(p, 0) = sun(p+16, line)	endif; determines the file name for the radiance imagepathrow = string(fix(pathrow))year = string(fix(year));comment the next line out if the radiance image is not to be written to disk;openw, un2, /get, strcompress(pathrow+'-'+year+'-radiance',/remove_all); determines the file name for the reflectance imageopenw, un3, /get, strcompress(pathrow+'-'+year+'-reflectance',/remove_all); This converts an input dn into radiance and reflectance; creating two filesfor k=0, nb-1 do begin  print,'Converting Band '+strmid(string(k+1),7,1)+' to Radiance and Reflectance: '+string(infile)  print, 'Using Cross Calibration Value: ',cross_cal(k)  print, 'Using Normalization Value: ',normalize(k)  for j=0,(nl-1) do begin    readu, un1, dn_img	;computes the radiance value for each pixel of dark object subtracted DN image    rad_img = ((gain(1,k) - gain(0,k))/255)*dn_img   ;Radiance = (LMAX - LMIN)/255 * DN    ;computes the reflectance value and applies cross calibration    ;also applies normalization value to 85 and mid year imagery	ref_img = ((3.1415*rad_img(*))/(esun(k))*cross_cal(k))    ;Reflectance	if (norm eq 1) then ref_img = ref_img*normalize(k)    ;writeu, un2, fix(round(rad_img*100))  ; commented out if radiance image is not wanted    writeu, un3, byte(round(ref_img*100))  endforendforclose, un1, un3 ;un2free_lun, un1, un3 ;un2end