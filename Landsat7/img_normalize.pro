pro img_normalize, flag, outfile, in_mask, base_mask, ns, nl, nb, num_pixels, infile, dns, dnl, dnb; This program creates a normalized bsq image from a base image;  and input image. This program does not alter any of the original;  data. A postscript of the plots is also generated.;; flag      - what operations to perform:;  (default) 0 - prints the correction values to an ASCII file;            1 - prints the postscript to outfile.ps + prints ASCII file;            2 - write the normalized image to outfile (BSQ format) + prints ASCII file;            3 - prints postscript and writes normalized image + prints ASCII file;    If flag is set to either 1 or 2, a prompt will ask for additional;     inputs:;       infile - the image to be normalized;       dns    - the number of samples in the image to be normalized;       dnl    - the number of lines in the image to be normalized;       dnb    - the number of bands in the image to be normalized; outfile   - the file to save the postscript/normalized image; in_mask   - the mask of infile; base_mask - the mask of the base image; ns        - the number of samples in the image; nl        - the number of lines in the image; nb        - the number of bands in the image; num_pixels- must be at least the number of pixels in the images (NL x NS x NB).;				however, a value of 6,000,000 is recomended, as it serves to force;				Zero to be the anchor point for the best-fit-line which is generated;; example (in IDL): img_normalize, 2, 'n.image','img.maksed', 'base_img.masked', 2500, 2500, 6, 'image', 8000, 8000, 6; I relaize however, that this is a large amount of data to enter at once, therefore, there is an easier way:;  example (in IDL): img_normalize;  IDL will then prompt you for the data which you did not enter before, but also allow you to scroll directoriesprint,' 'if (n_elements(flag) eq 0) then flag = 0if (flag eq 0) then print, 'Creating correction value file only' else $if (flag eq 1) then print, 'Creating PS file and correction value text file' else $if (flag eq 2) then print, 'Creating normalized image to outfile (BSQ) and correction value text file' else $if (flag eq 3) then print, 'Creating PS, normalize BSQ and correction value text file' else begin  flag=0  print, 'Creating postscript only'  print, ' 'endelseif (n_elements(in_mask) eq 0) then begin  print, 'Select the mask of the image to be normalized'  in_mask = DIALOG_PICKFILE(/READ, FILTER = '*',GET_PATH = img_path)endifif (n_elements(base_mask) eq 0) then begin  print, 'Select the mask of the reference image'  base_mask = DIALOG_PICKFILE(/READ, FILTER = '*')endifif (n_elements(ns) eq 0) then read, ns, prompt='Number of samples in this image: 'if (n_elements(nl) eq 0) then read, nl, prompt='Number of lines this image: 'if (n_elements(nb) eq 0) then read, nb, prompt='Number of bands this image: 'if (n_elements(num_pixels) eq 0) then read, num_pixels, prompt='Number of pixels in ROI mask: 'read, img_PathRow, prompt = 'Enter the Path/Row (PPRR):'img_PathRow = strcompress(fix(img_PathRow), /REMOVE_ALL)read, img_year, prompt = 'Enter the year this image was taken (YY):'img_year = strcompress(fix(img_year), /REMOVE_ALL)temp_outfile = string(img_PathRow)+'-'+string(img_year)outfile = string(img_path)+string(temp_outfile)x_title = string(in_mask)still_not_done = strpos(string(x_title),'/')while (still_not_done ne -1) do begin  for i=0,still_not_done do $    strput, x_title, ' ', i  x_title = strtrim(x_title,2)  still_not_done = strpos(string(x_title),'/')endwhilestill_not_done = strpos(string(x_title),'\')while (still_not_done ne -1) do begin  for i=0,still_not_done do $    strput, x_title, ' ', i  x_title = strtrim(x_title,2)  still_not_done = strpos(string(x_title),'\')endwhiley_title = string(base_mask)still_not_done = strpos(string(y_title),'/')while (still_not_done ne -1) do begin  for i=0,still_not_done do $    strput, y_title, ' ', i  y_title = strtrim(y_title,2)  still_not_done = strpos(string(y_title),'/')endwhilestill_not_done = strpos(string(y_title),'\')while (still_not_done ne -1) do begin  for i=0,still_not_done do $    strput, y_title, ' ', i  y_title = strtrim(y_title,2)  still_not_done = strpos(string(y_title),'\')endwhileopenr, un1, /get, string(in_mask)openr, un2, /get, string(base_mask)normalize_x = bytarr(ns,nl)reference_y = bytarr(ns,nl)non_zero_vals_x = bytarr(num_pixels)non_zero_vals_y = bytarr(num_pixels)slope = fltarr(nb,2)titles=['Band 1', $        'Band 2', $        'Band 3', $        'Band 4', $        'Band 5', $        'Band 7']print, ' 'for i=0,(nb-1) do begin  print, 'Analyzing '+titles(i)  readu, un1, normalize_x  readu, un2, reference_y  index = 0  for j=0, (ns-1) do begin    for k=0,(nl-1) do begin      if ((normalize_x(j,k) ne 0) or (reference_y(j,k) ne 0)) then begin        non_zero_vals_x(index) = normalize_x(j,k)        non_zero_vals_y(index) = reference_y(j,k)        index = index+1      endif    endfor  endfor  slope(i,*) = linfit(non_zero_vals_x(*), non_zero_vals_y(*));  slope(i,*) = linfit(normalize_x(*,*), reference_y(*,*))endfor  pstitles=[   'Band 1', $               'Band 2', $               'Band 3', $               'Band 4', $               'Band 5', $               'Band 7']openw, un3, string(outfile+'.NORM'), /getprintf, un3, string(temp_outfile)printf, un3, ' Path/Row '+string(img_PathRow)printf, un3, ' 96 to '+string(img_year)printf, un3, 'Normalize Values:'for i=0, (nb-1) do $  printf, un3, ' '+string(pstitles(i))+': '+strcompress(slope(i,1), /REMOVE_ALL)close, un1, un2, un3free_lun, un1, un2, un3print, ' 'if ((flag eq 1) or (flag eq 3)) then begin;prints the normalization data to outfile.ps  openr, un1, /get, string(in_mask)  openr, un2, /get, string(base_mask)  save=!p.multi  !p.multi=[0,2,3]  set_plot,'ps'  device,file=string(outfile)+'.ps',xsize=7.5, ysize=10, xoff=.5, yoff=.5, /inches  for i=0,(nb-1) do begin    readu, un1, normalize_x    readu, un2, reference_y    print, '((POSTSCRIPT)) Starting: ',titles(i)    plot,normalize_x(*,*),reference_y(*,*),psym=3, $    xrange=[0,200],xtitle=string(x_title),/xstyle, $    yrange=[0,200],ytitle=string(y_title),/ystyle, $    charsize=2.0, title=pstitles(i)    oplot,[0,200],slope(i,1)*[0,200]+slope(i,0)    xyouts, 1, 175, [slope(i,1)]  endfor  free_lun, un1, un2  print, 'created '+string(outfile)+'.ps'  print, ' '  device,/close;  set_plot,'x';  !p.multi=saveendifif ((flag eq 2) or (flag eq 3)) then begin; making a .bsq of infile normalized to base_img  print, 'Select the image to be normalized'  if (n_elements(infile) eq 0) then infile = DIALOG_PICKFILE(/READ, FILTER = '*')  print,'File to be normalized: '+string(infile)  if (n_elements(dns) eq 0) then read, dns, prompt='Number of samples in this image: '  if (n_elements(dnl) eq 0) then read, dnl, prompt='Number of lines in this image: '  if (n_elements(dnb) eq 0) then read, dnb, prompt='Number of bands in this image: '  openr, un3, /get, string(infile)  openw, un4, string(outfile), /get  normalize_img = bytarr(dns)  for k=0,(dnb-1) do begin    print,'Normalizing: '+string(infile)+' ('+string(titles(k))+')'    for j=0,(dnl-1) do begin      readu, un3, normalize_img      normalize_img(*) = fix(round(slope(k,1)*normalize_img(*)))      writeu, un4, normalize_img    endfor  endfor  free_lun, un3, un4  print, 'created '+string(outfile);  print, 'created '+string(outfile)+'.hdr'endifend